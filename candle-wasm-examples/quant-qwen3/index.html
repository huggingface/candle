<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Qwen3 WASM Text Generation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        .header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header h1 {
            color: #333;
            font-size: 32px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }
        .header a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }
        .header a:hover {
            text-decoration: underline;
        }
        .main-panel {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: center;
        }
        .status.loading {
            background: #fff3cd;
            color: #856404;
        }
        .status.ready {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        .prompt-section {
            margin-bottom: 20px;
        }
        .prompt-section label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        #prompt {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: inherit;
            transition: border-color 0.3s;
        }
        #maxTokens {
            width: 120px;
            padding: 12px;
            font-size: 18px;
            font-weight: 600;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: inherit;
            transition: border-color 0.3s;
            text-align: center;
        }
        #maxTokens:focus {
            outline: none;
            border-color: #667eea;
        }
        #prompt:focus {
            outline: none;
            border-color: #667eea;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
        }
        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        button.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button.secondary {
            background: #6c757d;
            color: white;
        }
        button.secondary:hover:not(:disabled) {
            background: #5a6268;
        }
        #stopBtn {
            background: #dc3545;
        }
        #stopBtn:hover:not(:disabled) {
            background: #c82333;
        }
        button:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
            transform: none !important;
        }
        #output {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .profiler-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }
        .profiler-controls h3 {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
        }
        .profiler-controls button {
            min-width: auto;
            padding: 8px 16px;
            font-size: 14px;
        }
        #memoryInfo {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            margin-top: 10px;
        }
        .footer {
            text-align: center;
            color: white;
            margin-top: 20px;
            font-size: 14px;
        }
        .thinking-section {
            margin: 20px 0;
            border: 2px solid #667eea;
            border-radius: 8px;
            overflow: hidden;
        }

        .thinking-toggle {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            font-size: 14px;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .thinking-toggle:hover {
            opacity: 0.9;
        }

        .thinking-output {
            padding: 20px;
            background: #f0f4ff;
            border-top: 1px solid #667eea;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>
                <span>Qwen3 Text Generation</span>
            </h1>
            <p>
                Running the <strong>Qwen3-0.6B</strong> language model directly in your browser using WebAssembly.
                Qwen3 is developed by the <a href="https://github.com/QwenLM/Qwen" target="_blank">Qwen team at Alibaba Cloud</a>.
            </p>
            <p>
                Quantized models from the <a href="https://huggingface.co/unsloth" target="_blank">Unsloth team</a>.
            </p>
            <p>
                Implementation by <a href="https://github.com/DrJesseGlass" target="_blank">Jesse Glass</a> using the Candle framework.
            </p>
        </div>

        <!-- Main Generation Panel -->
        <div class="main-panel">
            <div id="status" class="status loading">Initializing...</div>

            <div class="prompt-section">
                <label for="prompt">Enter your prompt:</label>
                <input
                    id="prompt"
                    type="text"
                    placeholder="Once upon a time..."
                    value="Once upon a time"
                />
            </div>

            <div class="prompt-section">
                <label for="maxTokens">Max tokens to generate:</label>
                <input
                    id="maxTokens"
                    type="number"
                    min="1"
                    max="500"
                    value="100"
                />
            </div>

            <div class="controls">
                <button id="generateBtn" class="primary" onclick="generate()" disabled>
                    Generate
                </button>
                <button id="stopBtn" class="secondary" onclick="stopGeneration()" disabled>
                    Stop Generation
                </button>
                <button id="resetBtn" class="secondary" onclick="reset()" disabled>
                    Reset
                </button>
            </div>

            <div id="thinkingSection" class="thinking-section" style="display: none;">
            <button class="thinking-toggle" onclick="toggleThinking()">
                <span id="thinkingArrow">▶</span> Reasoning Process
            </button>
            <div id="thinkingOutput" class="thinking-output" style="display: none;"></div>
        </div>

            <label>Response:</label>
            <div id="output"></div>

            <!-- Profiler Controls -->
            <div class="profiler-controls">
                <h3>Performance Tools</h3>
                <div class="controls">
                    <button class="secondary" onclick="showProfile()">Show Stats</button>
                    <button class="secondary" onclick="clearProfile()">Clear Stats</button>
                    <button class="secondary" onclick="updateMemory()">Update Memory</button>
                </div>
                <div id="memoryInfo">Loading memory info...</div>
            </div>
        </div>

        <div class="footer">
            Built with WebAssembly and Rust • Quantized model for fast inference
        </div>
    </div>

    <script type="module">
        import init, {
            Model,
            profile_print_stats,
            profile_clear,
            profile_enable,
            get_memory_info,
            get_wasm_memory_info,
            log_memory
        } from './pkg/candle_wasm_example_quant_qwen3.js';

        let model = null;
        let shouldStopGeneration = false;
        let fullResponse = '';
        let showThinkingCollapsed = false;

        const MODEL_FILE = window.location.pathname.endsWith('/') ?
            window.location.pathname.split('/').filter(Boolean).pop() + '.gguf' :
            'Qwen3-0.6B-Q8_0.gguf';

        function formatChatPrompt(userMessage) {
            return `<|im_start|>system
You are a helpful assistant.<|im_end|>
<|im_start|>user
${userMessage}<|im_end|>
<|im_start|>assistant
<think>
`;
        }

        function parseResponse(fullText) {
            if (fullText.includes('</think>')) {
                const thinkEndPos = fullText.indexOf('</think>');
                const thinkingRaw = fullText.substring(0, thinkEndPos);
                const responseRaw = fullText.substring(thinkEndPos + 8);

                return {
                    thinking: cleanTokens(thinkingRaw.replace(/<think>/g, '')),
                    response: cleanTokens(responseRaw)
                };
            } else {
                // Still building thinking
                const thinkingPartial = fullText.replace(/<think>/g, '');
                return {
                    thinking: cleanTokens(thinkingPartial),
                    response: ''
                };
            }
        }

        function cleanTokens(text) {
            return text
                .replace(/<\|im_start\|>/g, '')
                .replace(/<\|im_end\|>/g, '')
                .replace(/<\|endoftext\|>/g, '')
                .replace(/<think>/g, '')
                .replace(/<\/think>/g, '')
                .trim();
        }

        window.toggleThinking = function() {
            const output = document.getElementById('thinkingOutput');
            const arrow = document.getElementById('thinkingArrow');
            showThinkingCollapsed = !showThinkingCollapsed;

            if (showThinkingCollapsed) {
                output.style.display = 'block';
                arrow.textContent = '▼';
            } else {
                output.style.display = 'none';
                arrow.textContent = '▶';
            }
        };

        function updateStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        window.updateMemory = function() {
            const jsMemory = get_memory_info();
            const wasmMemory = get_wasm_memory_info();
            document.getElementById('memoryInfo').textContent =
                `JS Heap: ${jsMemory}\nWASM: ${wasmMemory}`;
        };

        window.showProfile = function() {
            profile_print_stats();
            updateStatus('Performance stats printed to console', 'ready');
        };

        window.clearProfile = function() {
            profile_clear();
            updateStatus('Stats cleared', 'ready');
        };

        window.stopGeneration = function() {
            shouldStopGeneration = true;
            updateStatus('Stopping generation...', 'loading');
        };

        async function loadModel() {
            try {
                updateStatus('Initializing WASM...', 'loading');
                await init();

                updateStatus('Loading model files...', 'loading');

                const [weights, tokenizer, config] = await Promise.all([
                    fetch(MODEL_FILE).then(r => {
                        if (!r.ok) throw new Error(`Failed to load ${MODEL_FILE}`);
                        return r.arrayBuffer();
                    }),
                    fetch('tokenizer.json').then(r => {
                        if (!r.ok) throw new Error('Failed to load tokenizer');
                        return r.arrayBuffer();
                    }),
                    fetch('config.json').then(r => {
                        if (!r.ok) throw new Error('Failed to load config');
                        return r.arrayBuffer();
                    }),
                ]);

                updateStatus('Creating model...', 'loading');
                profile_clear();

                model = new Model(
                    new Uint8Array(weights),
                    new Uint8Array(tokenizer),
                    new Uint8Array(config)
                );

                document.getElementById('generateBtn').disabled = false;
                document.getElementById('resetBtn').disabled = false;

                updateStatus('Model loaded and ready!', 'ready');
                updateMemory();

            } catch (e) {
                updateStatus(`Error: ${e.message}`, 'error');
                console.error('Load error:', e);
            }
        }

        window.generate = async function() {
            if (!model) return;

            const generateBtn = document.getElementById('generateBtn');
            const stopBtn = document.getElementById('stopBtn');
            const resetBtn = document.getElementById('resetBtn');
            const promptInput = document.getElementById('prompt');
            const outputDiv = document.getElementById('output');
            const thinkingOutputDiv = document.getElementById('thinkingOutput');
            const thinkingSection = document.getElementById('thinkingSection');
            const maxTokensInput = document.getElementById('maxTokens');

            generateBtn.disabled = true;
            stopBtn.disabled = false;
            resetBtn.disabled = true;
            promptInput.disabled = true;
            maxTokensInput.disabled = true;

            shouldStopGeneration = false;
            fullResponse = '';
            outputDiv.textContent = '';
            thinkingOutputDiv.textContent = '';
            thinkingSection.style.display = 'none';

            try {
                const userPrompt = promptInput.value;
                const formattedPrompt = formatChatPrompt(userPrompt);

                updateStatus('Generating...', 'loading');
                profile_clear();
                const startTime = Date.now();

                // Initialize with formatted prompt
                const firstToken = model.init_with_prompt(
                    formattedPrompt,
                    0.0,    // temperature (0 for deterministic)
                    0.0,    // top_p
                    1.1,    // repeat_penalty
                    64,     // repeat_last_n
                    42      // seed (fixed for reproducibility)
                );

                fullResponse += firstToken;
                let parsed = parseResponse(fullResponse);

                if (parsed.thinking) {
                    thinkingSection.style.display = 'block';
                    thinkingOutputDiv.textContent = parsed.thinking;
                }
                if (parsed.response) {
                    outputDiv.textContent = parsed.response;
                }

                let tokenCount = 1;
                const maxTokens = parseInt(maxTokensInput.value) || 100;

                // Generate tokens
                for (let i = 0; i < maxTokens - 1; i++) {
                    if (shouldStopGeneration) {
                        updateStatus('Generation stopped by user', 'ready');
                        break;
                    }

                    if (model.is_eos()) {
                        updateStatus('Generation complete (EOS reached)', 'ready');
                        break;
                    }

                    const token = model.next_token();
                    fullResponse += token;
                    tokenCount++;

                    // Parse and update displays
                    parsed = parseResponse(fullResponse);

                    if (parsed.thinking) {
                        thinkingSection.style.display = 'block';
                        thinkingOutputDiv.textContent = parsed.thinking;
                    }
                    if (parsed.response) {
                        outputDiv.textContent = parsed.response;
                    }

                    // Update status every 10 tokens
                    if (tokenCount % 10 === 0) {
                        const elapsed = (Date.now() - startTime) / 1000;
                        const tokensPerSec = (tokenCount / elapsed).toFixed(2);
                        updateStatus(`Generating... ${tokenCount} tokens (${tokensPerSec} tok/s)`, 'loading');
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                const totalTime = (Date.now() - startTime) / 1000;
                const tokensPerSec = (tokenCount / totalTime).toFixed(2);
                updateStatus(
                    `Generated ${tokenCount} tokens in ${totalTime.toFixed(2)}s (${tokensPerSec} tok/s)`,
                    'ready'
                );

                updateMemory();

            } catch (e) {
                updateStatus(`Error: ${e.message}`, 'error');
                console.error('Generation error:', e);
            } finally {
                generateBtn.disabled = false;
                stopBtn.disabled = true;
                resetBtn.disabled = false;
                promptInput.disabled = false;
                maxTokensInput.disabled = false;
            }
        };

        window.reset = function() {
            if (!model) return;
            model.reset();
            document.getElementById('output').textContent = '';
            document.getElementById('thinkingOutput').textContent = '';
            document.getElementById('thinkingSection').style.display = 'none';
            fullResponse = '';
            updateStatus('Model reset and ready!', 'ready');
            profile_clear();
        };

        // Start loading
        loadModel();
    </script>
</body>
</html>