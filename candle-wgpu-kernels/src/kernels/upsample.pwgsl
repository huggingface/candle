#include "util.pwgsl"

#define op_upsample1d_target_length                 op_meta[0]
#define op_upsample1d_input_size_batch              op_meta[1]
#define op_upsample1d_input_size_channel            op_meta[2]
#define op_upsample1d_input_size_x                  op_meta[3]
#define op_upsample1d_input_offset                  op_meta[4]

#define op_upsample1d_input_stride_batch            op_meta[5]
#define op_upsample1d_input_stride_channel          op_meta[6]
#define op_upsample1d_input_stride_x                op_meta[7]


#define op_upsample1d_output_stride_batch            op_meta[8]
#define op_upsample1d_ouput_stride_channel          op_meta[9]



//(N, C, L) -> (N,C, L_out)
@compute
@workgroup_size(64,1,1)
fn upsample1d(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index_input = global_id.x;
    let index_channel = global_id.y;
    let index_batch = global_id.z;

    if index_input >= op_upsample1d_target_length{
        return;
    }

    let factor = f32(op_upsample1d_input_size_x) / f32(op_upsample1d_target_length);

    let index = min(u32(f32(index_input) * factor), op_upsample1d_input_size_x - 1);

    v_dest[index_input + op_upsample1d_output_stride_batch * index_batch + op_upsample1d_ouput_stride_channel * index_channel] = v_input1[index * op_upsample1d_input_stride_x + op_upsample1d_input_stride_channel * index_channel + op_upsample1d_input_stride_batch * index_batch + op_upsample1d_input_offset];
}

#define op_upsample2d_target_length_y               op_meta[0]
#define op_upsample2d_target_length_x               op_meta[1]
#define op_upsample2d_input_size_batch              op_meta[2]
#define op_upsample2d_input_size_channel            op_meta[3]
#define op_upsample2d_input_size_y                  op_meta[4]
#define op_upsample2d_input_size_x                  op_meta[5]
#define op_upsample2d_input_offset                  op_meta[6]

#define op_upsample2d_input_stride_batch            op_meta[7]
#define op_upsample2d_input_stride_channel          op_meta[8]
#define op_upsample2d_input_stride_y                op_meta[9]
#define op_upsample2d_input_stride_x                op_meta[10]


#define op_upsample2d_output_stride_batch           op_meta[11]
#define op_upsample2d_output_stride_channel          op_meta[12]
#define op_upsample2d_output_stride_y                op_meta[13]


//(N, C, H, W) -> (N,C, H_out, W_out)
@compute
@workgroup_size(8,8,1)
fn upsample2d(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index_input_x = global_id.x;
    let index_input_y = global_id.y;
    let index_channel = global_id.z;

    if index_input_x >= op_upsample2d_target_length_x || index_input_y >= op_upsample2d_target_length_y{
        return;
    }
    
    let factor_x = f32(op_upsample2d_input_size_x) / f32(op_upsample2d_target_length_x);
    let index_x = min(u32(f32(index_input_x) * factor_x), op_upsample2d_input_size_x - 1);

    let factor_y = f32(op_upsample2d_input_size_y) / f32(op_upsample2d_target_length_y);
    let index_y = min(u32(f32(index_input_y) * factor_y), op_upsample2d_input_size_y - 1);

    for(var index_batch = 0u; index_batch < op_upsample2d_input_size_batch; index_batch++){
        v_dest[
            op_upsample2d_output_stride_batch * index_batch + 
            op_upsample2d_output_stride_channel * index_channel +
            op_upsample2d_output_stride_y  * index_input_y + 
            index_input_x] = 
        v_input1[
            op_upsample2d_input_stride_batch * index_batch +
            op_upsample2d_input_stride_channel * index_channel +
            op_upsample2d_input_stride_y * index_y + 
            op_upsample2d_input_stride_x * index_x +
            op_upsample2d_input_offset];
    }

}


@compute
@workgroup_size(8, 8, 1)
fn upsample_bilinear2d(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // op_meta:
    // [0] = N
    // [1] = C
    // [2] = in_h
    // [3] = in_w
    // [4] = out_h
    // [5] = out_w
    // [6] = src_offset
    // [7] = align_corners (0/1)
    // [8] = use_scale (0/1)
    // [9] = scale_h (f32 bits)
    // [10] = scale_w (f32 bits)

    let N = op_meta[0];
    let C = op_meta[1];
    let in_h = op_meta[2];
    let in_w = op_meta[3];
    let out_h = op_meta[4];
    let out_w = op_meta[5];
    let src_offset = op_meta[6];
    let align_corners = op_meta[7];
    let use_scale = op_meta[8];

    // Reinterpret scale bits
    let scale_h: f32 = bitcast<f32>(op_meta[9]);
    let scale_w: f32 = bitcast<f32>(op_meta[10]);

    let nc = global_id.x;    // 0 .. N*C-1
    let i = global_id.y;     // 0 .. out_h*out_w-1

    if (nc >= N * C) { return; }
    if (i >= out_h * out_w) { return; }

    let n_idx = nc / C;
    let c_idx = nc % C;

    let out_y = i / out_w;
    let out_x = i % out_w;

    // Compute scale factors
    var sy: f32;
    var sx: f32;

    if (use_scale == 1u) {
        sy = scale_h;
        sx = scale_w;
    } else {
        if (align_corners == 1u) {
            if (out_h > 1u) {
                sy = f32(in_h - 1u) / f32(out_h - 1u);
            } else {
                sy = 0.0;
            }
            if (out_w > 1u) {
                sx = f32(in_w - 1u) / f32(out_w - 1u);
            } else {
                sx = 0.0;
            }
        } else {
            sy = f32(in_h) / f32(out_h);
            sx = f32(in_w) / f32(out_w);
        }
    }


    // Map output -> input coordinates
    var in_y_f : f32;
    var in_x_f : f32;

    if (in_h == 1u) {
        in_y_f = 0.0;
    } else {
        if (align_corners == 1u) {
            in_y_f = f32(out_y) * sy;
        } else {
            in_y_f = (f32(out_y) + 0.5) * sy - 0.5;
        }
    }

    if (in_w == 1u) {
        in_x_f = 0.0;
    } else {
        if (align_corners == 1u) {
            in_x_f = f32(out_x) * sx;
        } else {
            in_x_f = (f32(out_x) + 0.5) * sx - 0.5;
        }
    }
    // PyTorch border behavior for align_corners = false
    if (align_corners == 0u) {
        in_y_f = clamp(in_y_f, 0.0, f32(in_h - 1u));
        in_x_f = clamp(in_x_f, 0.0, f32(in_w - 1u));
    }

    // Compute integer neighbors
    let in_y0 = i32(floor(in_y_f));
    let in_x0 = i32(floor(in_x_f));

    let y0 = clamp(in_y0, 0, i32(in_h) - 1);
    let x0 = clamp(in_x0, 0, i32(in_w) - 1);
    let y1 = min(y0 + 1, i32(in_h) - 1);
    let x1 = min(x0 + 1, i32(in_w) - 1);

    let wy = in_y_f - f32(in_y0);
    let wx = in_x_f - f32(in_x0);

    // NCHW layout:
    // idx = ((n * C + c) * H + y) * W + x
    let base_nc = (n_idx * C + c_idx) * in_h * in_w;

    let idx00 = base_nc + u32(y0) * in_w + u32(x0);
    let idx01 = base_nc + u32(y0) * in_w + u32(x1);
    let idx10 = base_nc + u32(y1) * in_w + u32(x0);
    let idx11 = base_nc + u32(y1) * in_w + u32(x1);

    let v00: DTYPE = v_input1[idx00 + src_offset];
    let v01: DTYPE = v_input1[idx01 + src_offset];
    let v10: DTYPE = v_input1[idx10 + src_offset];
    let v11: DTYPE = v_input1[idx11 + src_offset];

    // Bilinear interpolation
    let v0 = v00 * (1.0 - wx) + v01 * wx;
    let v1 = v10 * (1.0 - wx) + v11 * wx;
    let v = v0 * (1.0 - wy) + v1 * wy;

    // Output index: NCHW
    let out_base_nc = (n_idx * C + c_idx) * out_h * out_w;
    let out_idx = out_base_nc + out_y * out_w + out_x;

    v_dest[out_idx] = v;
}
