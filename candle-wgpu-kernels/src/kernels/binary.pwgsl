#include "util.pwgsl"

fn set_binary(operation : u32, id : u32, x : DTYPE, y : DTYPE){
    switch(operation){
        case 0u{
            v_dest[id] = y;
        }
        case 1u{ //add
            v_dest[id] = x + y;
        }
        case 2u{ //mult
            v_dest[id] = x * y;
        }
        case 3u{ //minus
            v_dest[id] = x - y;
        }
        case 4u{ //div
            v_dest[id] = x / y;
        }
        case 5u{ //max
            v_dest[id] = max(x, y);
        }
        case 6u{ //min
            v_dest[id] = min(x, y);
        }
#ifdef f32        
        case 7u{ //powf
            v_dest[id] = pow(x, y);
        }
#endif
        default{

        }
    }
}



override CONSTV_0 : u32 = 1u;
override CONSTV_1 : bool = true;
override CONSTV_2 : bool = true;
override USE_Z : bool = false;

#define op_binary_operation         CONSTV_0

#define op_binary_input1_layout     0u

LOAD_INFO(op_binary_info, 3)
#define op_binary_contiguous_both_operation                 CONSTV_0
#define op_binary_contiguous_both_input1_length             op_binary_info[0]
#define op_binary_contiguous_both_is_input1_offset_zero     CONSTV_1
#define op_binary_contiguous_both_is_input2_offset_zero     CONSTV_2

#define op_binary_contiguous_both_input1_offset             select(op_binary_info[1], 0u,op_binary_contiguous_both_is_input1_offset_zero)
#define op_binary_contiguous_both_input2_offset             select(op_binary_info[2], 0u,op_binary_contiguous_both_is_input2_offset_zero)

LOAD_INFO_UNKNOWN_SIZE(op_binary, 0)

@compute
@workgroup_size(64,1,1)
fn binary_buffer_from_buffer(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let id = global_id.x + select(0u, global_id.y * 65535 * 64,USE_Z);

    GET_INDEX1(op_binary,op_binary_input1_layout, id, pos1_is_valid, pos1_id)
    GET_INDEX2(op_binary,op_binary_input1_layout, id, pos2_is_valid, pos2_id)

    if(pos1_is_valid){
        set_binary(op_binary_operation, id, v_input1[pos1_id], v_input2[pos2_id]);
    }
}

@compute
@workgroup_size(64,1,1)
fn binary_buffer_from_buffer_same_stride(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let id = global_id.x + select(0u, global_id.y * 65535 * 64,USE_Z);

    GET_INDEX1(op_binary,op_binary_input1_layout, id, pos1_is_valid, pos1_id);
    
    if(pos1_is_valid){
        set_binary(op_binary_operation, id, v_input1[pos1_id], v_input2[pos1_id]);
    }
}


@compute
@workgroup_size(64,1,1)
fn binary_buffer_from_buffer_contiguous_both(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let id = global_id.x + select(0u, global_id.y * 65535 * 64,USE_Z);
    if (id >= op_binary_contiguous_both_input1_length){
        return;
    }
    set_binary(op_binary_contiguous_both_operation, id, v_input1[id + op_binary_contiguous_both_input1_offset], v_input2[id + op_binary_contiguous_both_input2_offset]);
}

@compute
@workgroup_size(64,1,1)
fn binary_buffer_inplace1_contiguous_both(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let id = global_id.x + select(0u, global_id.y * 65535 * 64,USE_Z);
    if (id >= op_binary_contiguous_both_input1_length){
        return;
    }
    let offset1 = op_binary_contiguous_both_input1_offset; //is only used so that the shader compiles if op_binary_contiguous_both_input1_offset is set
    set_binary(op_binary_contiguous_both_operation, id, v_dest[id], v_input1[id + op_binary_contiguous_both_input2_offset]);
}

@compute
@workgroup_size(64,1,1)
fn binary_buffer_inplace2_contiguous_both(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let id = global_id.x + select(0u, global_id.y * 65535 * 64,USE_Z);
    if (id >= op_binary_contiguous_both_input1_length){
        return;
    }
    let offset2 = op_binary_contiguous_both_input2_offset; //is only used so that the shader compiles if op_binary_contiguous_both_input2_offset is set
    set_binary(op_binary_contiguous_both_operation, id, v_input1[id + op_binary_contiguous_both_input1_offset], v_dest[id]);
}