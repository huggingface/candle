#ifdef f32
#define DTYPE f32 
#endif

#ifdef u32
#define DTYPE u32 
#endif

#ifdef u8
#define DTYPE u32 
#endif

#ifdef i64
#define DTYPE i64
#endif

#ifdef f64
#define DTYPE f64
#endif

#ifdef f16
enable f16;
#define DTYPE f16
#endif


@group(0) @binding(0)
var<storage, read_write> v_dest: array<DTYPE>;

@group(0) @binding(0)
var<storage, read_write> v_dest_4: array<vec4<DTYPE>>;

@group(0) @binding(0)
var<storage, read_write> v_dest_u32: array<u32>;

@group(0) @binding(0)
var<storage, read_write> v_dest_f32: array<f32>;

@group(0) @binding(0)
var<storage, read_write> v_dest_i64: array<i64>;

@group(0) @binding(0)
var<storage, read_write> v_dest_f64: array<f64>;


@group(0) @binding(1)
var<storage> op_meta : array<u32>;



@group(0) @binding(2)
var<storage> v_input1: array<DTYPE>;

@group(0) @binding(2)
var<storage> v_input1_4: array<vec4<DTYPE>>;

@group(0) @binding(2)
var<storage> v_input1_u32: array<u32>;

@group(0) @binding(2)
var<storage> v_input1_i64: array<i64>;



@group(0) @binding(3)
var<storage> v_input2: array<DTYPE>;

@group(0) @binding(3)
var<storage> v_input2_4: array<vec4<DTYPE>>;


@group(0) @binding(4)
var<storage> v_input3: array<DTYPE>;






const ZERO : DTYPE = 0;
const ONE : DTYPE = 1;

#ifdef f32

const MINVALUE : f32 = -3.40282e+38;
const MAXVALUE : f32 =  3.40282e+38;
#define TODTYPE f32

#elifdef u32

const MINVALUE : u32 = 0;
const MAXVALUE : u32 = 4294967295;
#define TODTYPE u32

#elifdef i32

const MINVALUE : i32 = -2147483648;
const MAXVALUE : i32 =  2147483647;
#define TODTYPE i32

#elifdef i64

const MINVALUE : i64 = -9223372036854775807;
const MAXVALUE : i64 =  9223372036854775807;
#define TODTYPE i64

#elifdef f64

const MINVALUE : f64 = -1.7976931348623157E+308;
const MAXVALUE : f64 = 1.7976931348623157E+308;
#define TODTYPE f64

#elifdef f16
const MINVALUE : f16 = -65504;
const MAXVALUE : f16 = 65504;
#define TODTYPE f16

#elifdef u8

const MINVALUE : u32 = 0;
const MAXVALUE : u32 = 255;
#define TODTYPE u32

#endif

struct MatrixIndex{
    id : u32,
    is_valid : bool
}


/// f16 <-> f32
/// https://stackoverflow.com/questions/1659440/32-bit-to-16-bit-floating-point-conversion
fn as_uint(x: f32) -> u32 {
    return bitcast<u32>(x);
}

fn as_float(x: u32) -> f32 {
    return bitcast<f32>(x);
}

fn half_to_float(x: u32) -> f32 {

    let e: u32 = (x & 0x7C00u) >> 10u; // Extract exponent
    let m: u32 = (x & 0x03FFu) << 13u; // Extract and shift mantissa
    let v: u32 = as_uint(f32(m)) >> 23u; // Approximate log2 for denormals

    let sign: u32 = (x & 0x8000u) << 16u;
    let normalized: u32 = select(0u, ((e + 112u) << 23u) | m, e != 0u);
    let denormalized: u32 = select(0u, ((v - 37u) << 23u) | ((m << (150u - v)) & 0x007FE000u), e == 0u && m != 0u);

    return as_float(sign | normalized | denormalized);
}

fn float_to_half(x: f32) -> u32 {
    let b: u32 = as_uint(x) + 0x00001000u; // Round to nearest-even
    let e: u32 = (b & 0x7F800000u) >> 23u; // Extract exponent
    let m: u32 = b & 0x007FFFFFu; // Extract mantissa

    let sign: u32 = (b & 0x80000000u) >> 16u;
    let normalized: u32 = select(0u, (((e - 112u) << 10u) & 0x7C00u) | (m >> 13u), e > 112u);
    let denormalized: u32 = select(0u, (((0x007FF000u + m) >> (125u - e)) + 1u) >> 1u, e < 113u && e > 101u);
    let saturated: u32 = select(0x7FFFu, 0u, e <= 143u);

    return u32(sign | normalized | denormalized | saturated);
}

override CONST_DIMS1 : u32 = 1u;
override CONST_IS_CONTIGUOUS1 : bool = true;
override CONST_IS_STARTOFFSET_ZERO1 : bool = true;

override CONST_DIMS2 : u32 = 1u;
override CONST_IS_CONTIGUOUS2 : bool = true;
override CONST_IS_STARTOFFSET_ZERO2 : bool = true;

override CONST_DIMS3 : u32 = 1u;
override CONST_IS_CONTIGUOUS3 : bool = true;
override CONST_IS_STARTOFFSET_ZERO3 : bool = true;

fn get_index(input_offset : u32, index : u32, dims : u32, is_contiguous : bool, is_const_start_offset_zero : bool) -> MatrixIndex{
    let start_offset = select(op_meta[input_offset], 0u,is_const_start_offset_zero);
    let start_shape_offset = input_offset + select(1u, 0u,is_const_start_offset_zero);

    if is_contiguous {
        let length = op_meta[start_shape_offset];
       
        if index < length{
            return MatrixIndex((start_offset + index), true);
        }
        return MatrixIndex(0, false);
    }
    else{
        var shapes_i = 1u;
        var new_index = start_offset;    
        for (var i2 : i32 = i32(dims) - 1; i2 >= 0; i2--){
            let i = u32(i2);
            let prev_shapes_i = shapes_i;
            shapes_i *= op_meta[start_shape_offset + i]; 

            let si = (index / prev_shapes_i) % (shapes_i / prev_shapes_i);  
            new_index += si * op_meta[start_shape_offset + dims + i]; //s_i * stride_i
        }

        if index >= shapes_i{ //in shapes_i is the length after the for loop
            return MatrixIndex(0, false);
        }

        return MatrixIndex(new_index, true);
    }
}

fn get_index1(input_offset : u32, index : u32) -> MatrixIndex{
    return get_index(input_offset, index, CONST_DIMS1, CONST_IS_CONTIGUOUS1, CONST_IS_STARTOFFSET_ZERO1);
}

fn get_index2(input_offset : u32, index : u32) -> MatrixIndex{
    return get_index(input_offset, index, CONST_DIMS2, CONST_IS_CONTIGUOUS2, CONST_IS_STARTOFFSET_ZERO2);
}

fn get_index3(input_offset : u32, index : u32) -> MatrixIndex{
    return get_index(input_offset, index, CONST_DIMS3, CONST_IS_CONTIGUOUS3, CONST_IS_STARTOFFSET_ZERO3);
}

fn get_size(dims : u32, is_contiguous : bool, is_const_start_offset_zero : bool) -> u32{
    let start_shape_size = select(1u, 0u,is_const_start_offset_zero);
    if is_contiguous{ 
        return start_shape_size + 1u;
    }
    else {
        return start_shape_size + dims * 2;
    }
}

fn get_size1() -> u32{
    return get_size(CONST_DIMS1, CONST_IS_CONTIGUOUS1, CONST_IS_STARTOFFSET_ZERO1);
}

fn get_size2() -> u32{
    return get_size(CONST_DIMS2, CONST_IS_CONTIGUOUS2, CONST_IS_STARTOFFSET_ZERO2);
}

fn get_size3() -> u32{
    return get_size(CONST_DIMS3, CONST_IS_CONTIGUOUS3, CONST_IS_STARTOFFSET_ZERO3);
}