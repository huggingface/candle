#define BLOCK_SIZE 32
#define BIT_SIZE 5

#define D_OFFSET 0
#define M_OFFSET 2
#define QH_OFFSET 4
#define QS_OFFSET 8

#define TS 1
#define WGS 1
#define TID_SIZE 4

#pp_begin LOAD_HEADER(data)
let block_starting_byte = block_index * BLOCK_BYTE_SIZE;
let block_qs_byte = block_starting_byte + QS_OFFSET;
let header_data1 = load_u32(data, block_starting_byte / 4u);
let d = half_to_float(header_data1 & 0xFFFF);
let m = half_to_float((header_data1>> 16) & 0xFFFF);
#if (QH_OFFSET % 4 == 0) && (BLOCK_BYTE_SIZE % 4 == 0)
    let qh = data[(block_starting_byte + QH_OFFSET) / 4];
#else
    let qh = load_data(data,block_starting_byte+QH_OFFSET,0xFFFF) | (load_data(data,block_starting_byte+QH_OFFSET+2,0xFFFF)) << 16 ;
#endif
#pp_end

#pp_begin LOAD_SINGLE (data, tid, VALUES_PER_THREAD)
    let THREADS_PER_BLOCK = BLOCK_SIZE / VALUES_PER_THREAD;
    let loads_per_thread = (VALUES_PER_THREAD / 8u); //we load 8 values (u32) at the same time
    let j = tid * loads_per_thread;
    
    let start = block_qs_byte / 4u + j;

    //naive solution
    //for(var m = 0u; m < VALUES_PER_THREAD;m++){
    //      let x_u8 = load_data(data,block_qs_byte + j * VALUES_PER_THREAD + m,0xFF);
    //      let x0 = x_u8 & 0x0F;
    //      let x1 = x_u8 >> 4;
    //      #define DEFAULT_M_OFFSET 8
    //      CALLBACK(j * VALUES_PER_THREAD + m          , f32(i32(x0) - DEFAULT_M_OFFSET)*d)
    //      CALLBACK(j * VALUES_PER_THREAD + m + 16, f32(i32(x1) - DEFAULT_M_OFFSET)*d)
    // }

    for(var l = 0u; l < loads_per_thread; l += 1u){
        let x_u32 = load_u32(data, start + l * loads_per_thread);
        let out_base = j * 4u + l * 4u;
        
        let x12_u8 = x_u32 & 0xFF;
        let x34_u8 = (x_u32 >> 8)  & 0xFF;
        let x56_u8 = (x_u32 >> 16) & 0xFF;
        let x78_u8 = (x_u32 >> 24) & 0xFF;

        let x0 = (x12_u8 & 0x0F) | (((qh >> out_base) << 4) & 0x10);
        let x1 = (x12_u8 >> 4) | ((qh >> ((out_base) + 12)) & 0x10);
        let x2 = (x34_u8 & 0x0F) | (((qh >> (out_base + 1)) << 4) & 0x10);
        let x3 = (x34_u8 >> 4) | ((qh >> ((out_base + 1) + 12)) & 0x10);
        let x4 = (x56_u8 & 0x0F) | (((qh >> (out_base + 2)) << 4) & 0x10);
        let x5 = (x56_u8 >> 4) | ((qh >> ((out_base + 2) + 12)) & 0x10);
        let x6 = (x78_u8 & 0x0F) | (((qh >> (out_base + 3)) << 4) & 0x10);
        let x7 = (x78_u8 >> 4) | ((qh >> ((out_base + 3) + 12)) & 0x10);
        #define DEFAULT_M_OFFSET 16
        #definec BLOCK_SIZE_HALF_MINUS_1 (BLOCK_SIZE/2-1)
        let index12 = (out_base + 0) & BLOCK_SIZE_HALF_MINUS_1;
        let index34 = (out_base + 1) & BLOCK_SIZE_HALF_MINUS_1;
        let index56 = (out_base + 2) & BLOCK_SIZE_HALF_MINUS_1;
        let index78 = (out_base + 3) & BLOCK_SIZE_HALF_MINUS_1;
        CALLBACK(index12, f32(x0)*d+m)
        CALLBACK(index12 + 16, f32(x1)*d+m)
        CALLBACK(index34, f32(x2)*d+m)
        CALLBACK(index34 + 16, f32(x3)*d+m)
        CALLBACK(index56, f32(x4)*d+m)
        CALLBACK(index56 + 16, f32(x5)*d+m)
        CALLBACK(index78, f32(x6)*d+m)
        CALLBACK(index78 + 16, f32(x7)*d+m)
    }
#pp_end


#include "quantHelper.pwgsl"

#ifdef SGEMM
#include "matmulHelperSgemm.pwgsl"

#define WIDTHA 4u
#definec WIDTHB VALUES_PER_THREAD 

MATMUL(matmul_sgemm)
#endif

