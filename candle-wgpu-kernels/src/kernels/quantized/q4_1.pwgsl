#define BLOCK_SIZE 32
#define BIT_SIZE 4

#define D_OFFSET 0
#define M_OFFSET 2
#define QS_OFFSET 4


#define TS 1
#define WGS 1
#define TID_SIZE 4
//tid0 loads 0-3 and 16-19, (loads 8 value), but the stride for tid1 is 4 (it must load) 4-7 and 20-24
#define STRIDE_WIDTHB 4
#define CUSTOM_QUANTIZED_INDEX(i, base) base + i % 4 + (i / 4u) * 16u
//0-3 or 2-5 makes 6 values for the first 4, and 16-19 and 18-21 makes the other 6 needed for A
//#define SIZE_AREG 12

//#define CUSTOM_QUANTIZED_INDEX(base, i) ((base / 32) * 32) + (base % 32 + i) % 32

#pp_begin LOAD_HEADER(data)
let block_starting_byte = block_index * BLOCK_BYTE_SIZE;
#ifdef QS_OFFSET
    let block_qs_byte = block_starting_byte + QS_OFFSET;
#endif

// single header word load (contains header bytes and possibly first data bytes)
let header_data1 = load_u32(data, block_starting_byte / 4u);
let d = half_to_float(header_data1 & 0xFFFF);
let m = half_to_float((header_data1>> 16) & 0xFFFF);
#pp_end

#pp_begin LOAD_SINGLE (data,tid)
    let THREADS_PER_BLOCK = BLOCK_SIZE / VALUES_PER_THREAD;
    let loads_per_thread = (VALUES_PER_THREAD / 8u); //we load 8 values (u32) at the same time
    let j = tid * loads_per_thread;
    
    let start = block_qs_byte / 4u + j;

    for(var l = 0u; l < loads_per_thread; l += 1u){
        let x_u32 = load_u32(data, start + l * loads_per_thread);
        let out_base = j * 4u + l * 4u;

        let x12_u8 = x_u32 & 0xFF;
        let x34_u8 = (x_u32 >> 8)  & 0xFF;
        let x56_u8 = (x_u32 >> 16) & 0xFF;
        let x78_u8 = (x_u32 >> 24) & 0xFF;

        let x0 = x12_u8 & 0x0F;
        let x1 = x12_u8 >> 4;
        let x2 = x34_u8 & 0x0F;
        let x3 = x34_u8 >> 4;
        let x4 = x56_u8 & 0x0F;
        let x5 = x56_u8 >> 4;
        let x6 = x78_u8 & 0x0F;
        let x7 = x78_u8 >> 4;
        #define DEFAULT_M_OFFSET 8
        #definec BLOCK_SIZE_HALF_MINUS_1 (BLOCK_SIZE/2-1)
        let index12 = (out_base + 0) & BLOCK_SIZE_HALF_MINUS_1;
        let index34 = (out_base + 1) & BLOCK_SIZE_HALF_MINUS_1;
        let index56 = (out_base + 2) & BLOCK_SIZE_HALF_MINUS_1;
        let index78 = (out_base + 3) & BLOCK_SIZE_HALF_MINUS_1;
        CALLBACK(index12, f32(x0)*d+m, 0u)
        CALLBACK(index12 + 16, f32(x1)*d+m, 4u)
        CALLBACK(index34, f32(x2)*d+m, 1u)
        CALLBACK(index34 + 16, f32(x3)*d+m, 5u)
        CALLBACK(index56, f32(x4)*d+m, 2u)
        CALLBACK(index56 + 16, f32(x5)*d+m, 6u)
        CALLBACK(index78, f32(x6)*d+m, 3u)
        CALLBACK(index78 + 16, f32(x7)*d+m, 7u)
    }
#pp_end


#include "quantHelper.pwgsl"

#ifdef SGEMM
#define WIDTHA 4u
#definec WIDTHB VALUES_PER_THREAD 
#include "matmulHelperSgemm.pwgsl"



MATMUL(matmul_sgemm)
#endif

