#include "util.pwgsl"

// Interleaved rotary embeddings (y0 = x0*cos - x1*sin ; y1 = x0*sin + x1*cos)
//
// Buffers:
// @group(0) @binding(0) var<storage, read_write> v_dest: array<DTYPE>;   // output (same layout as src)
// @group(0) @binding(1) var<storage> op_meta : array<u32>;             // small parameter list
// @group(0) @binding(2) var<storage> v_input1: array<DTYPE>;           // src (s1)
// @group(0) @binding(3) var<storage> v_input2: array<DTYPE>;           // cos  (s2)
// @group(0) @binding(4) var<storage> v_input3: array<DTYPE>;           // sin  (s3)
//
// op_meta layout (u32):
// [0] = B         // batch
// [1] = H         // heads
// [2] = T         // tokens / seq length
// [3] = D         // head dim (must be even; interleaved x0/x1 pairs -> D/2 pairs)
// [4] = unbatched_rope  // 0 => batched rope (shared across batches), 1 => unbatched rope (separate per batch)
//
// Work distribution:
//   global_invocation_id.x -> bh_index  (0..B*H-1)  (flattened batch*head)
//   global_invocation_id.y -> i_over_2   (0..T * (D/2) - 1)  (flat over tokens * pair-index)
//   z dimension left unused (1)

override CONSTV_0 : u32 = 0u;

@compute
@workgroup_size(8,8,1)
fn rotary_emb_i(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // read op_meta
    let B = op_meta[0];
    let H = op_meta[1];
    let T = op_meta[2];
    let D = op_meta[3];

    let src_offset = op_meta[4];
    let cos_offset = op_meta[5];
    let sin_offset = op_meta[6];

    let unbatched = CONSTV_0;

    // quick guards (avoid runtime panic / OOB)
    if (D == 0u) { return; }                 // nothing to do
    // D must be even
    if ((D & 1u) == 1u) { return; }

    let half = D / 2u;                        // number of (x0,x1) pairs per head
    let BH = B * H;
    // compute flat indices from dispatch
    let bh = global_id.x;                     // 0 .. B*H-1
    let i_over_2 = global_id.y;               // 0 .. T*half - 1

    // bounds checks
    if (bh >= BH) { return; }
    if (i_over_2 >= T * half) { return; }

    // decompose bh into batch and head
    let b_idx = bh / H;
    let h_idx = bh % H;

    // from i_over_2 we can get token index and pair index within the head dim
    let token_idx = i_over_2 / half;           // 0 .. T-1
    let pair_idx = i_over_2 % half;            // 0 .. half-1

    // compute base offsets:
    // src layout is contiguous (B, H, T, D) flattened row-major:
    // index = ((b * H + h) * T + token) * D + dim
    let src_head_base = ((b_idx * H + h_idx) * T + token_idx) * D;

    // pair element positions
    let idx0 = src_head_base + (pair_idx * 2u);      // x0
    let idx1 = idx0 + 1u;                            // x1

    // compute rope (cos/sin) index:
    // match CPU implementation:
    // - when batched rope (unbatched==0): cos/sin length == T * half, and mapping is rope_i = i_over_2
    // - when unbatched rope (unbatched==1): cos/sin length == B * T * half, and mapping is rope_i = i_over_2 + b_idx * T * half
    var rope_i: u32 = 0u;
    if (unbatched == 1u) {
        rope_i = i_over_2 + b_idx * (T * half);
    } else {
        rope_i = i_over_2;
    }

    // load values (assume contiguous storage, no layout helpers)
    // NOTE: shader assumes v_input1, v_input2, v_input3 contain enough elements and are contiguous as described.
    let x0: DTYPE = v_input1[idx0 + src_offset];
    let x1: DTYPE = v_input1[idx1 + src_offset];
    let c: DTYPE = v_input2[rope_i + cos_offset];
    let s: DTYPE = v_input3[rope_i + sin_offset];

    // compute rotary interleaved pair
    // y0 = x0 * cos - x1 * sin
    // y1 = x0 * sin + x1 * cos
    let y0: DTYPE = x0 * c - x1 * s;
    let y1: DTYPE = x0 * s + x1 * c;

    // write back
    v_dest[idx0] = y0;
    v_dest[idx1] = y1;
}