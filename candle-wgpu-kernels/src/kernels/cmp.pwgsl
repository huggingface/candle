#include "util.pwgsl"

LOAD_INFO_UNKNOWN_SIZE(op_cmp, 2)
#define op_binary_operation         op_cmp[0]
#define op_binary_dest_size         op_cmp[1]
#define op_binary_input1_layout     2u

fn bool_to_int(b : bool) -> u32{
    if b{
        return 1u;
    }
    return 0u;
}

@compute
@workgroup_size(64,1,1)
fn cmp_buffer_from_buffer(@builtin(global_invocation_id) global_id: vec3<u32>) { //One Shader needs to handle 4 comps
    let id = global_id.x;
    var output_value = 0u;

    if(id >= op_binary_dest_size){
        return;
    }
 
    for (var i = 0u; i < 4; i++){
        GET_INDEX1(op_cmp,op_binary_input1_layout, id * 4 + i, pos1_is_valid, pos1_id)
        if(!pos1_is_valid){
            continue;
        }
        GET_INDEX2(op_cmp,op_binary_input1_layout, id * 4 + i, pos2_is_valid, pos2_id)

        let x = v_input1[pos1_id];
        let y = v_input2[pos2_id];

        switch(op_binary_operation){
            case 0u: { //eq
                output_value |= bool_to_int(x == y) << (i * 8);
            }
            case 1u: {//ne
                output_value |=  bool_to_int(x != y) << (i * 8);
            }
            case 2u: {//lt
                output_value |=  bool_to_int(x < y) << (i * 8);
            }
            case 3u: {//LE
                output_value |= bool_to_int(x <= y) << (i * 8);
            }
            case 4u: {//GT
                output_value |= bool_to_int(x > y) << (i * 8);
            }
            case 5u: {//GE
                output_value |=  bool_to_int(x >= y) << (i * 8);
            }
            default:{
                
            }
        }
    }

    v_dest_u32[id] = output_value;   
}